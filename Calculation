import math

MIN_MUNICIPAL_POP = 50000   # e.g. 50k (low scenario)
MAX_MUNICIPAL_POP = 55000   # e.g. 55k (high scenario)

MIN_MUNICIPAL_AREA = 680    # e.g. 680 km² (low scenario)
MAX_MUNICIPAL_AREA = 700    # e.g. 700 km² (high scenario)

# Growth rate range (e.g. 2.0% to 3.0%)
MIN_GROWTH_RATE = 0.02      # 2% annual growth
MAX_GROWTH_RATE = 0.03      # 3% annual growth

YEARS = 3                   # Project over years

# Radii of interest, in km
RADII_KM = [3, 5]

def average_density_range(min_pop, max_pop, min_area, max_area):
    """
    Given a municipality's population range and area range,
    return the (low_density, high_density) in people/km².
    
    low_density uses: min_pop / max_area
    high_density uses: max_pop / min_area
    
    This ensures the broadest possible range for density.
    """
    # Low-end density: smallest pop / largest area => lower density
    low_density = min_pop / max_area
    # High-end density: largest pop / smallest area => higher density
    high_density = max_pop / min_area
    return (low_density, high_density)


def circle_area(radius_km):
    """Calculate the area (in km²) of a circle with a given radius (km)."""
    return math.pi * (radius_km ** 2)


def estimate_pop_range_for_radius(radius_km, low_density, high_density):
    """
    Given a radius and a range of densities (people/km²),
    return (low_pop, high_pop) for that radius.
    """
    area = circle_area(radius_km)
    # Low-end population = circle area * low density
    pop_low = area * low_density
    # High-end population = circle area * high density
    pop_high = area * high_density
    return (pop_low, pop_high)


def compound_growth_range(pop_low, pop_high, min_rate, max_rate, years):
    """
    Return a population range after 'years' of compound growth,
    given a low and high current population and a min & max growth rate.
    
    We'll compute:
      - lowest future pop = pop_low * (1 + min_rate)^years
      - highest future pop = pop_high * (1 + max_rate)^years
    """
    # Low-end scenario: low population growing at the min_rate
    future_low = pop_low * ((1 + min_rate) ** years)
    # High-end scenario: high population growing at the max_rate
    future_high = pop_high * ((1 + max_rate) ** years)
    return (future_low, future_high)

def main():
    # Get the (low_density, high_density) from the municipal range
    (low_density, high_density) = average_density_range(
        MIN_MUNICIPAL_POP,
        MAX_MUNICIPAL_POP,
        MIN_MUNICIPAL_AREA,
        MAX_MUNICIPAL_AREA
    )
    
    print("=== RADIUS-BASED POPULATION ESTIMATES (CURRENT) ===")
    print(f"Municipal Population Range: {MIN_MUNICIPAL_POP:,} - {MAX_MUNICIPAL_POP:,}")
    print(f"Municipal Area Range: {MIN_MUNICIPAL_AREA:,} - {MAX_MUNICIPAL_AREA:,} km²")
    print(f"Derived Density Range: {low_density:.2f} - {high_density:.2f} people/km²\n")
    
    for r_km in RADII_KM:
        (pop_low, pop_high) = estimate_pop_range_for_radius(r_km, low_density, high_density)
        
        print(f"Radius: {r_km} km")
        print(f"  Current Population Range: {pop_low:,.0f} - {pop_high:,.0f}")
        
        (fut_low, fut_high) = compound_growth_range(pop_low, pop_high, MIN_GROWTH_RATE, MAX_GROWTH_RATE, YEARS)
        
        print(f"  {YEARS}-Year Projection (using {MIN_GROWTH_RATE*100:.1f}% to {MAX_GROWTH_RATE*100:.1f}% growth):")
        print(f"    Future Pop Range: {fut_low:,.0f} - {fut_high:,.0f}\n")

if __name__ == "__main__":
    main()
